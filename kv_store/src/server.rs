// This file contains the implementation of the Server struct. The Server struct is responsible for handling incoming messages, sending outgoing messages, and updating the database based on the decided entries from the OmniPaxos instance. The run method of the Server struct is the main event loop that processes incoming messages, sends outgoing messages, and updates the database in a loop. The run method uses tokio::select! to handle multiple asynchronous tasks concurrently.

//Importing the necessary modules and structs
use crate::database::Database;
use crate::kv::{
    KVCommand,
};
use crate::{
    network::{Message, Network},
    OmniPaxosKV,
    NODES,
    PID as MY_PID,
};
use omnipaxos::{
    util::LogEntry,
    util::SnapshottedEntry,
};
use serde::{Deserialize, Serialize};
use std::{
    time::Duration,
    fs, 
    path::Path, 
};
use tokio::time;

//Defines the types of responses the server can send back to a client
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum APIResponse {
    //Indicates that a new log index has been decided
    Decided(u64),
    //Represents the result of a GET operation on the kv store, where the first part is the key and the second part is the optional value (Can be None if the key does not exist)
    Get(String, Option<String>),
}

//Defines the Server struct
pub struct Server {
    pub omni_paxos: OmniPaxosKV, //OmniPaxos instance for the server
    pub network: Network, //Manages sending and receiving messages from other nodes or clients.
    pub database: Database, //Handles the actual storage and retrieval of key-value pairs.
    pub last_decided_idx: u64, //Tracks the last log entry that was "decided" (i.e., agreed upon by the consensus process) and applied to the database.
}

// Implementing the Server struct
impl Server {

    
    async fn process_incoming_msgs(&mut self) {
        let messages = self.network.get_received().await;
        for msg in messages {
            match msg {
                Message::APIRequest(kv_cmd) => match kv_cmd {
                    KVCommand::Get(key) => {
                        let value = self.database.handle_command(KVCommand::Get(key.clone()));
                        let msg = Message::APIResponse(APIResponse::Get(key, value));
                        // Send response to client (0 is the clientID)
                        self.network.send(0, msg).await;
                    }
                    cmd => {
                        self.omni_paxos.append(cmd).unwrap();
                    }
                },
                Message::OmniPaxosMsg(msg) => {
                    self.omni_paxos.handle_incoming(msg);
                }, 
                Message::Debug(msg) => {
                    //println!("Debug: {}", msg);
                },
                Message::Reconnect(pid) => {
                    if self.omni_paxos.get_current_leader().map(|(id, _)| id) != Some(*MY_PID) {
                        println!("Reconnecting node {}, from {}", pid, *MY_PID);
                        self.omni_paxos.reconnected(pid);
                    }
                },
                _ => unimplemented!(),
            }
        }
    }

    //Collects messages generated by OmniPaxos component that need to be sent to other nodes and sends them
    async fn send_outgoing_msgs(&mut self) {
        let messages = self.omni_paxos.outgoing_messages();
        for msg in messages {
            let receiver = msg.get_receiver();
            self.network
                .send(receiver, Message::OmniPaxosMsg(msg))
                .await;
        }
    }

    async fn handle_decided_entries(&mut self) {
        let new_decided_idx = self.omni_paxos.get_decided_idx();
        //Check if there are new decided entries
        if self.last_decided_idx < new_decided_idx as u64 {
            let decided_entries = self
                .omni_paxos
                .read_decided_suffix(self.last_decided_idx as usize)
                .unwrap();

            //Upate the database with the decided entries, and save the current latest decided index
            self.update_database(decided_entries);
            self.last_decided_idx = new_decided_idx as u64;
            /*** reply to client with new decided index ***/
            let msg = Message::APIResponse(APIResponse::Decided(new_decided_idx as u64));
            self.network.send(0, msg).await;
            // snapshotting
            if new_decided_idx % 5 == 0 {
                println!(
                    "Log before: {:?}",
                    self.omni_paxos.read_decided_suffix(0).unwrap()
                );
                self.omni_paxos
                    .snapshot(Some(new_decided_idx), true)
                    .expect("Failed to snapshot");
                println!(
                    "Log after: {:?}\n",
                    self.omni_paxos.read_decided_suffix(0).unwrap()
                );
            }
        }
    }

    //Iterates over decided log entries and applies each command to the database. This is how the state of the database is eventually updated based on the decisions made by the consensus algorithm.
    fn update_database(&self, decided_entries: Vec<LogEntry<KVCommand>>) {
        for entry in decided_entries {
            match entry {
                LogEntry::Decided(cmd) => {
                    self.database.handle_command(cmd);
                },
                LogEntry::Snapshotted(SnapshottedEntry { snapshot, .. }) => {
                    self.database.handle_snapshot(snapshot);
                },
                _ => {}
            }
        }
    }

    async fn debug_heartbeat(&mut self) {
        //Send a debug message to nodes 1, 2, and 3 saying "Heartbeat from node <MY_PID>"
        let peers: Vec<u64> = NODES
            .iter()
            .filter(|pid| **pid != *MY_PID)
            .cloned()
            .collect();
        for pid in peers {
            let msg = Message::Debug(format!("Heartbeat from node {}", *MY_PID));
            self.network.send(pid, msg).await;
        }
    }

    //Main loop of the server that processes incoming messages, sends outgoing messages, and updates the database based on decided entries.
    //The run method uses tokio::select! to handle multiple asynchronous tasks concurrently.
    //The biased; directive gives priority to the first branch (message processing).
    pub(crate) async fn run(&mut self) {
        // Create a longer-lived string to fix the borrow error
        let path_string = format!("db_{}", *MY_PID);
        let db_path = Path::new(&path_string).parent();
        if let Some(parent) = db_path {
            if !parent.exists() {
                fs::create_dir_all(parent).expect("Failed to create db directory");
            }
        }

        // Set up any necessary recovery tracking
        let initial_sync_start = std::time::Instant::now();
        let mut recovery_complete = false;
        
        let mut msg_interval = time::interval(Duration::from_millis(1));
        let mut tick_interval = time::interval(Duration::from_millis(10));
        let mut debug_heartbeat = time::interval(Duration::from_secs(2));
        loop {
            tokio::select! {
                biased;
                _ = msg_interval.tick() => {
                    self.process_incoming_msgs().await;
                    self.send_outgoing_msgs().await;
                    self.handle_decided_entries().await;
                    
                    // Check if recovery is complete
                    if !recovery_complete {
                        // Consider node recovered if it has processed some decided entries
                        // or it has been running for at least 10 seconds
                        if self.last_decided_idx > 0 || initial_sync_start.elapsed().as_secs() > 10 {
                            recovery_complete = true;
                            println!("Recovery complete in {}ms", initial_sync_start.elapsed().as_millis());
                        }
                    }
                },
                _ = tick_interval.tick() => {
                    self.omni_paxos.tick();
                },
                _ = debug_heartbeat.tick() => {
                    self.debug_heartbeat().await;
                    let end = self.omni_paxos.get_decided_idx();
                    if let Some(entries) = self.omni_paxos.read_entries(0..) {
                        println!("--------");
                        for entry in entries {
                            println!("{:?}", entry);
                        }
                        println!("--------");
                    } else {
                        println!("No entries found in the log or out of bounds.");
                    }
                },
                else => (),
            }
        }
    }
}
